import { geometry, drawing } from '@progress/kendo-drawing';
import { deepExtend, addClass, Observable, setDefaultOptions } from '../common';
import { calculateSankey, crossesValue } from './calculation';
import { Node, resolveNodeOptions } from './node';
import { Link, resolveLinkOptions } from './link';
import { Label, resolveLabelOptions } from './label';
import { Title } from './title';
import { BOTTOM, LEFT, RIGHT, TOP } from '../common/constants';
import { Box, rectToBox } from '../core';
import { Legend } from './legend';
import { defined } from '../drawing-utils';

var LINK = 'link';
var NODE = 'node';

export var Sankey = (function (Observable) {
    function Sankey(element, options, theme) {
        Observable.call(this);

        this._initTheme(theme);
        this._setOptions(options);
        this._initElement(element);
        this._initSurface();

        if (options && options.data) {
            this._redraw();
            this._initResizeObserver();
        }
    }

    if ( Observable ) Sankey.__proto__ = Observable;
    Sankey.prototype = Object.create( Observable && Observable.prototype );
    Sankey.prototype.constructor = Sankey;

    Sankey.prototype.destroy = function destroy () {
        this.unbind();
        this._destroySurface();
        this._destroyResizeObserver();
    };

    Sankey.prototype._initElement = function _initElement (element) {
        this.element = element;
        addClass(element, [ "k-chart", "k-sankey" ]);
        element.setAttribute('role', 'graphics-document');
        element.tabIndex = element.getAttribute("tabindex") || 0;

        var ref = this.options;
        var title = ref.title;

        if (title.text) {
            element.setAttribute('aria-label', title.text);
        }

        if (title.description) {
            element.setAttribute("aria-roledescription", title.description);
        }
    };

    Sankey.prototype._initSurface = function _initSurface () {
        if (!this.surface) {
            this._destroySurface();
            this._initSurfaceElement();
            this.surface = this._createSurface();
        }
    };

    Sankey.prototype._initResizeObserver = function _initResizeObserver () {
        var this$1 = this;

        var observer = new ResizeObserver(function (entries) {
            entries.forEach(function (entry) {
                var ref = entry.contentRect;
                var width = ref.width;
                var height = ref.height;
                if (entry.target !== this$1.element ||
                    (this$1.size && this$1.size.width === width && this$1.size.height === height)) {
                    return;
                }
                this$1.size = { width: width, height: height };
                this$1.surface.setSize(this$1.size);
                this$1.resize = true;
                this$1._redraw();
            });
        });
        this._resizeObserver = observer;
        observer.observe(this.element);
    };

    Sankey.prototype._createSurface = function _createSurface () {
        return drawing.Surface.create(this.surfaceElement, {
            mouseenter: this._mouseenter.bind(this),
            mouseleave: this._mouseleave.bind(this),
            mousemove: this._mousemove.bind(this),
            click: this._click.bind(this)
        });
    };

    Sankey.prototype._initTheme = function _initTheme (theme) {
        var currentTheme = theme || this.theme || {};
        this.theme = currentTheme;
        this.options = deepExtend({}, currentTheme, this.options);
    };

    Sankey.prototype.setLinksOpacity = function setLinksOpacity (opacity) {
        var this$1 = this;

        this.linksVisuals.forEach(function (link) {
            this$1.setOpacity(link, opacity, link.linkOptions.opacity);
        });
    };

    Sankey.prototype.setLinksInactivityOpacity = function setLinksInactivityOpacity (inactiveOpacity) {
        var this$1 = this;

        this.linksVisuals.forEach(function (link) {
            this$1.setOpacity(link, inactiveOpacity, link.linkOptions.highlight.inactiveOpacity);
        });
    };

    Sankey.prototype.setOpacity = function setOpacity (link, opacity, linkValue) {
        link.options.set('stroke', Object.assign({}, link.options.stroke,
            {opacity: defined(linkValue) ? linkValue : opacity}));
    };

    Sankey.prototype.trigger = function trigger (name, ev) {
        var event = Object.assign({}, ev,
            {type: name,
            targetType: ev.element.type,
            dataItem: ev.element.dataItem});

        return Observable.prototype.trigger.call(this, name, event);
    };

    Sankey.prototype._mouseenter = function _mouseenter (ev) {
        var element = ev.element;
        var isLink = element.type === LINK;
        var isNode = element.type === NODE;
        var isLegendItem = Boolean(element.chartElement && element.chartElement.options.node);

        if ((isLink && this.trigger('linkEnter', ev)) ||
            (isNode && this.trigger('nodeEnter', ev))) {
            return;
        }

        var ref = this.options.links;
        var highlight = ref.highlight;
        if (isLink) {
            this.setLinksInactivityOpacity(highlight.inactiveOpacity);
            this.setOpacity(element, highlight.opacity, element.linkOptions.highlight.opacity);
        } else if (isNode) {
            this.highlightLinks(element, highlight);
        } else if (isLegendItem) {
            var nodeVisual = this.nodesVisuals.get(element.chartElement.options.node.id);
            this.highlightLinks(nodeVisual, highlight);
        }
    };

    Sankey.prototype._mouseleave = function _mouseleave (ev) {
        var this$1 = this;

        var element = ev.element;
        var isLink = element.type === LINK;
        var isNode = element.type === NODE;
        var isLegendItem = Boolean(element.chartElement && element.chartElement.options.node);
        var target = ev.originalEvent.relatedTarget;

        if (isLink && target && target.nodeName === 'text') {
            return;
        }

        if (isLink || isNode) {
            if (this.tooltipTimeOut) {
                clearTimeout(this.tooltipTimeOut);
                this.tooltipTimeOut = null;
            }
            this.tooltipShown = false;
            this.trigger('tooltipHide', ev);
        }

        if ((isLink && this.trigger('linkLeave', ev)) ||
            (isNode && this.trigger('nodeLeave', ev))) {
            return;
        }

        if (isLink || isNode || isLegendItem) {
            this.linksVisuals.forEach(function (link) {
                this$1.setOpacity(link, this$1.options.links.opacity, link.linkOptions.opacity);
            });
        }
    };

    Sankey.prototype._mousemove = function _mousemove (ev) {
        var this$1 = this;

        var ref = this.options.tooltip;
        var followPointer = ref.followPointer;
        var delay = ref.delay;
        var element = ev.element;
        var tooltipElType = element.type;

        if ((tooltipElType !== LINK && tooltipElType !== NODE) || (this.tooltipShown && !followPointer)) {
            return;
        }

        var mouseEvent = ev.originalEvent;
        var rect = this.element.getBoundingClientRect();
        var isLeft = mouseEvent.clientX - rect.left < rect.width / 2;
        var isTop = mouseEvent.clientY - rect.top < rect.height / 2;

        ev.tooltipData = {
            popupOffset: {
                left: mouseEvent.pageX,
                top: mouseEvent.pageY
            },
            popupAlign: {
                horizontal: isLeft ? 'left' : 'right',
                vertical: isTop ? 'top' : 'bottom'
            }
        };

        if (tooltipElType === NODE) {
            var ref$1 = element.dataItem;
            var sourceLinks = ref$1.sourceLinks;
            var targetLinks = ref$1.targetLinks;
            var links = targetLinks.length ? targetLinks : sourceLinks;
            ev.nodeValue = links.reduce(function (acc, link) { return acc + link.value; }, 0);
        }

        if (this.tooltipTimeOut) {
            clearTimeout(this.tooltipTimeOut);
            this.tooltipTimeOut = null;
        }

        var nextDelay = followPointer && this.tooltipShown ? 0 : delay;

        this.tooltipTimeOut = setTimeout(function () {
            this$1.trigger('tooltipShow', ev);
            this$1.tooltipShown = true;
            this$1.tooltipTimeOut = null;
        }, nextDelay);
    };

    Sankey.prototype._click = function _click (ev) {
        var element = ev.element;
        var isLink = element.type === LINK;
        var isNode = element.type === NODE;

        if (isNode) {
            this.trigger('nodeClick', ev);
        } else if (isLink) {
            this.trigger('linkClick', ev);
        }
    };

    Sankey.prototype.highlightLinks = function highlightLinks (node, highlight) {
        var this$1 = this;

        if (node) {
            this.setLinksInactivityOpacity(highlight.inactiveOpacity);
            node.links.forEach(function (link) {
                this$1.setOpacity(link, highlight.opacity, link.linkOptions.highlight.opacity);
            });
        }
    };

    Sankey.prototype._destroySurface = function _destroySurface () {
        if (this.surface) {
            this.surface.destroy();
            this.surface = null;
            this._destroySurfaceElement();
        }
    };

    Sankey.prototype._destroyResizeObserver = function _destroyResizeObserver () {
        if (this._resizeObserver) {
            this._resizeObserver.disconnect();
            this._resizeObserver = null;
        }
    };

    Sankey.prototype._initSurfaceElement = function _initSurfaceElement () {
        if (!this.surfaceElement) {
            this.surfaceElement = document.createElement('div');
            this.element.appendChild(this.surfaceElement);
        }
    };

    Sankey.prototype._destroySurfaceElement = function _destroySurfaceElement () {
        if (this.surfaceElement && this.surfaceElement.parentNode) {
            this.surfaceElement.parentNode.removeChild(this.surfaceElement);
            this.surfaceElement = null;
        }
    };

    Sankey.prototype.setOptions = function setOptions (options, theme) {
        this._setOptions(options);
        this._initTheme(theme);
        this._initSurface();
        this._redraw();
    };

    Sankey.prototype._redraw = function _redraw () {
        this.surface.clear();

        var ref = this._getSize();
        var width = ref.width;
        var height = ref.height;
        this.size = { width: width, height: height };
        this.surface.setSize(this.size);

        this.createVisual();

        this.surface.draw(this.visual);
    };

    Sankey.prototype._getSize = function _getSize () {
        return this.element.getBoundingClientRect();
    };

    Sankey.prototype.createVisual = function createVisual () {
        this.visual = this._render();
    };

    Sankey.prototype.titleBox = function titleBox (title, drawingRect) {
        if (!title || title.visible === false || !title.text) {
            return null;
        }

        var titleElement = new Title(Object.assign({}, {drawingRect: drawingRect}, title));
        var titleVisual = titleElement.exportVisual();
        return titleVisual.chartElement.box;
    };

    Sankey.prototype.legendBox = function legendBox (options, nodes, drawingRect) {
        if (!options || options.visible === false) {
            return null;
        }

        var legend = new Legend(Object.assign({}, {nodes: nodes}, options, {drawingRect: drawingRect}));
        var legendVisual = legend.exportVisual();

        return legendVisual.chartElement.box;
    };

    Sankey.prototype.calculateSankey = function calculateSankey$1 (calcOptions, sankeyOptions) {
        var title = sankeyOptions.title;
        var legend = sankeyOptions.legend;
        var data = sankeyOptions.data;
        var nodes = sankeyOptions.nodes;
        var labels = sankeyOptions.labels;
        var nodeColors = sankeyOptions.nodeColors;
        var disableAutoLayout = sankeyOptions.disableAutoLayout;
        var autoLayout = !disableAutoLayout;

        var sankeyBox = new Box(0, 0, calcOptions.width, calcOptions.height);
        var titleBox = this.titleBox(title, sankeyBox);

        var legendArea = sankeyBox.clone();

        if (titleBox) {
            var titleHeight = titleBox.height();
            if (title.position === TOP) {
                sankeyBox.unpad({ top: titleHeight });
                legendArea = new Box(0, titleHeight, calcOptions.width, calcOptions.height);
            } else {
                sankeyBox.shrink(0, titleHeight);
                legendArea = new Box(0, 0, calcOptions.width, calcOptions.height - titleHeight);
            }
        }

        var legendBox = this.legendBox(legend, data.nodes, legendArea);
        var legendPosition = (legend && legend.position) || Legend.prototype.options.position;

        if (legendBox) {
            if (legendPosition === LEFT) {
                sankeyBox.unpad({ left: legendBox.width() });
            }

            if (legendPosition === RIGHT) {
                sankeyBox.shrink(legendBox.width(), 0);
            }

            if (legendPosition === TOP) {
                sankeyBox.unpad({ top: legendBox.height() });
            }

            if (legendPosition === BOTTOM) {
                sankeyBox.shrink(0, legendBox.height());
            }
        }

        var ref = calculateSankey(Object.assign({}, calcOptions, {offsetX: 0, offsetY: 0, width: sankeyBox.width(), height: sankeyBox.height()}));
        var calculatedNodes = ref.nodes;
        var circularLinks = ref.circularLinks;
        if (circularLinks) {
            console.warn('Circular links detected. Kendo Sankey diagram does not support circular links.');
            return { sankey: { nodes: [], links: [], circularLinks: circularLinks }, legendBox: legendBox, titleBox: titleBox };
        }

        var box = new Box();

        calculatedNodes.forEach(function (nodeEl, i) {
            var nodeOps = resolveNodeOptions(nodeEl, nodes, nodeColors, i);
            var nodeInstance = new Node(nodeOps);
            box.wrap(rectToBox(nodeInstance.exportVisual().rawBBox()));

            var labelInstance = new Label(resolveLabelOptions(nodeEl, labels, sankeyBox.width()));
            var labelVisual = labelInstance.exportVisual();
            if (labelVisual) {
                box.wrap(rectToBox(labelVisual.rawBBox()));
            }
        });

        var offsetX = sankeyBox.x1;
        var offsetY = sankeyBox.y1;

        var width = sankeyBox.width() + offsetX;
        var height = sankeyBox.height() + offsetY;

        width -= box.x2 > sankeyBox.width() ? box.x2 - sankeyBox.width() : 0;
        height -= box.y2 > sankeyBox.height() ? box.y2 - sankeyBox.height() : 0;

        offsetX += box.x1 < 0 ? -box.x1 : 0;
        offsetY += box.y1 < 0 ? -box.y1 : 0;

        if (autoLayout === false) {
            return {
                sankey: calculateSankey(Object.assign({}, calcOptions, {offsetX: offsetX, offsetY: offsetY, width: width, height: height, autoLayout: false})),
                legendBox: legendBox,
                titleBox: titleBox
            };
        }

        if (this.resize && autoLayout && this.permutation) {
            this.resize = false;
            return {
                sankey: calculateSankey(Object.assign({}, calcOptions, {offsetX: offsetX, offsetY: offsetY, width: width, height: height}, this.permutation)),
                legendBox: legendBox,
                titleBox: titleBox
            };
        }

        var startColumn = 1;
        var loops = 2;
        var columnsLength = calculateSankey(Object.assign({}, calcOptions, {offsetX: offsetX, offsetY: offsetY, width: width, height: height, autoLayout: false})).columns.length;
        var results = [];

        var permutation = function (targetColumnIndex, reverse) {
            var currPerm = calculateSankey(Object.assign({}, calcOptions, {offsetX: offsetX, offsetY: offsetY, width: width, height: height, loops: loops, targetColumnIndex: targetColumnIndex, reverse: reverse}));
            var crosses = crossesValue(currPerm.links);
            results.push({
                crosses: crosses,
                reverse: reverse,
                targetColumnIndex: targetColumnIndex
            });
            return crosses === 0;
        };

        for (var index = startColumn; index <= columnsLength - 1; index++) {
            if (permutation(index, false) || permutation(index, true)) {
                break;
            }
        }

        var minCrosses = Math.min.apply(null, results.map(function (r) { return r.crosses; }));
        var bestResult = results.find(function (r) { return r.crosses === minCrosses; });
        this.permutation = { targetColumnIndex: bestResult.targetColumnIndex, reverse: bestResult.reverse };
        var result = calculateSankey(Object.assign({}, calcOptions, {offsetX: offsetX, offsetY: offsetY, width: width, height: height}, this.permutation));

        return {
            sankey: result,
            legendBox: legendBox,
            titleBox: titleBox
        };
    };

    Sankey.prototype._render = function _render (options, context) {
        var sankeyOptions = options || this.options;
        var sankeyContext = context || this;

        var data = sankeyOptions.data;
        var labelOptions = sankeyOptions.labels;
        var nodesOptions = sankeyOptions.nodes;
        var linkOptions = sankeyOptions.links;
        var nodeColors = sankeyOptions.nodeColors;
        var title = sankeyOptions.title;
        var legend = sankeyOptions.legend;
        var ref = sankeyContext.size;
        var width = ref.width;
        var height = ref.height;

        var calcOptions = Object.assign({}, data, {width: width, height: height, nodesOptions: nodesOptions, title: title, legend: legend});
        var ref$1 = this.calculateSankey(calcOptions, sankeyOptions);
        var sankey = ref$1.sankey;
        var titleBox = ref$1.titleBox;
        var legendBox = ref$1.legendBox;
        var nodes = sankey.nodes;
        var links = sankey.links;

        var visual = new drawing.Group({
            clip: drawing.Path.fromRect(new geometry.Rect([0, 0], [width, height]))
        });

        if (titleBox) {
            var titleElement = new Title(Object.assign({}, title, {drawingRect: titleBox}));
            var titleVisual = titleElement.exportVisual();
            visual.append(titleVisual);
        }

        if (sankey.circularLinks) {
            return visual;
        }

        var visualNodes = new Map();
        sankeyContext.nodesVisuals = visualNodes;

        nodes.forEach(function (node, i) {
            var nodeOps = resolveNodeOptions(node, nodesOptions, nodeColors, i);

            var nodeInstance = new Node(nodeOps);
            var nodeVisual = nodeInstance.exportVisual();
            nodeVisual.links = [];
            nodeVisual.type = NODE;

            node.color = nodeOps.color;
            node.opacity = nodeOps.opacity;

            nodeVisual.dataItem = Object.assign({}, data.nodes[i],
                {color: nodeOps.color,
                opacity: nodeOps.opacity,
                sourceLinks: node.sourceLinks.map(function (link) { return ({ sourceId: link.sourceId, targetId: link.targetId, value: link.value }); }),
                targetLinks: node.targetLinks.map(function (link) { return ({ sourceId: link.sourceId, targetId: link.targetId, value: link.value }); })});
            visualNodes.set(node.id, nodeVisual);

            visual.append(nodeVisual);
        });

        var sortedLinks = links.slice().sort(function (a, b) { return b.value - a.value; });

        var linksVisuals = [];
        sankeyContext.linksVisuals = linksVisuals;

        sortedLinks.forEach(function (link) {
            var source = link.source;
            var target = link.target;
            var sourceNode = visualNodes.get(source.id);
            var targetNode = visualNodes.get(target.id);
            var linkOps = resolveLinkOptions(link, linkOptions, sourceNode, targetNode);
            var linkInstance = new Link(linkOps);
            var linkVisual = linkInstance.exportVisual();

            linkVisual.type = LINK;
            linkVisual.dataItem = {
                source: Object.assign({}, sourceNode.dataItem),
                target: Object.assign({}, targetNode.dataItem),
                value: link.value
            };
            linkVisual.linkOptions = linkOps;
            linksVisuals.push(linkVisual);

            sourceNode.links.push(linkVisual);
            targetNode.links.push(linkVisual);

            visual.append(linkVisual);
        });

        var diagramWidth = nodes.reduce(function (acc, node) { return Math.max(acc, node.x1); }, 0);
        nodes.forEach(function (node) {
            var textOps = resolveLabelOptions(node, labelOptions, diagramWidth);
            var labelInstance = new Label(textOps);
            var labelVisual = labelInstance.exportVisual();

            if (labelVisual) {
                visual.append(labelVisual);
            }
        });

        if (legendBox) {
            var legendElement = new Legend(Object.assign({}, legend, {drawingRect: legendBox, nodes: nodes}));
            var legendVisual = legendElement.exportVisual();
            visual.append(legendVisual);
        }

        return visual;
    };

    Sankey.prototype.exportVisual = function exportVisual (exportOptions) {
        var options = (exportOptions && exportOptions.options) ?
            deepExtend({}, this.options, exportOptions.options) : this.options;

        var context = {
            size: {
                width: defined(exportOptions && exportOptions.width) ? exportOptions.width : this.size.width,
                height: defined(exportOptions && exportOptions.height) ? exportOptions.height : this.size.height
            }
        };

        return this._render(options, context);
    };

    Sankey.prototype._setOptions = function _setOptions (options) {
        this.options = deepExtend({}, this.options, options);
    };

    return Sankey;
}(Observable));

setDefaultOptions(Sankey, {
    title: {
        position: TOP, // 'top', 'bottom'
    },
    labels: {
        visible: true,
        margin: {
            left: 8,
            right: 8
        },
        padding: 0,
        border: {
            width: 0
        },
        paintOrder: 'stroke',
        stroke: {
            lineJoin: "round",
            width: 1
        },
        align: LEFT,
        offset: { left: 0, top: 0 }
    },
    nodes: {
        width: 24,
        padding: 16,
        opacity: 1,
        align: 'stretch', // 'left', 'right', 'stretch'
        offset: { left: 0, top: 0 }
    },
    links: {
        colorType: 'static', // 'source', 'target', 'static'
        opacity: 0.4,
        highlight: {
            opacity: 0.8,
            inactiveOpacity: 0.2
        }
    },
    tooltip: {
        followPointer: false,
        delay: 200
    }
});
