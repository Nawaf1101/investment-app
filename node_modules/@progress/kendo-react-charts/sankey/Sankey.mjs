/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as t from "react";
import { Sankey as w } from "@progress/kendo-charts";
import { loadTheme as x } from "./theme-service.mjs";
import { validatePackage as O, canUseDOM as D } from "@progress/kendo-react-common";
import { packageMetadata as H } from "../package-metadata.mjs";
import { sankeyPropTypes as I } from "./propTypes.mjs";
import { TooltipComponent as M, NodeTooltipContent as V, LinkTooltipContent as A } from "./SankeyTooltip.mjs";
const h = 12, p = {
  offset: h,
  visible: !0
}, F = ["nodeEnter", "nodeLeave", "linkEnter", "linkLeave", "nodeClick", "linkClick"], K = (o, s) => {
  o && (o.unbind(), F.forEach((r) => {
    s[r] && o.bind(r, s[r]);
  }));
}, N = t.forwardRef((o, s) => {
  O(H);
  const r = t.useRef(null), n = t.useRef(null), u = t.useRef(null), { data: f, links: k, nodes: m, labels: y, title: E, legend: v, tooltip: c = p, disableAutoLayout: C } = o, b = t.useRef();
  b.current = o;
  const [T, g] = t.useState(null), L = t.useCallback((l) => {
    const {
      visible: a,
      offset: e = h,
      nodeComponent: d = V,
      linkComponent: S = A
    } = { ...p, ...c };
    if (a) {
      const P = {
        event: l,
        offset: e,
        Content: l.targetType === "node" ? d : S
      };
      g(P);
    }
  }, [c]), R = t.useCallback(() => {
    g(null);
  }, []), i = t.useCallback((l, a) => {
    const e = b.current[l];
    if (e) {
      const d = {
        ...a,
        nativeEvent: a.originalEvent,
        target: u.current
      };
      e.call(void 0, d);
    }
  }, []);
  return t.useEffect(() => {
    const l = {
      data: f,
      links: k,
      nodes: m,
      labels: y,
      title: E,
      legend: v,
      disableAutoLayout: C,
      tooltip: { ...p, ...c }
    };
    return n.current ? n.current.setOptions(l) : D && r.current && x(r.current.ownerDocument, (a) => {
      n.current = new w(r.current, l, a), K(n.current, {
        nodeEnter: (e) => {
          i("onNodeEnter", e);
        },
        nodeLeave: (e) => {
          i("onNodeLeave", e);
        },
        linkEnter: (e) => {
          i("onLinkEnter", e);
        },
        linkLeave: (e) => {
          i("onLinkLeave", e);
        },
        nodeClick: (e) => {
          i("onNodeClick", e);
        },
        linkClick: (e) => {
          i("onLinkClick", e);
        }
      }), n.current.bind("tooltipShow", L), n.current.bind("tooltipHide", R);
    }), () => {
      n.current && (n.current.destroy(), n.current = null);
    };
  }, [f, k, m, y, E, v, C, c, R, L, i]), t.useImperativeHandle(u, () => ({
    get element() {
      return r.current;
    },
    exportVisual: (l) => n.current.exportVisual(l),
    props: o
  }), []), t.useImperativeHandle(s, () => u.current), /* @__PURE__ */ t.createElement(t.Fragment, null, /* @__PURE__ */ t.createElement(
    "div",
    {
      ref: r,
      className: o.className,
      style: o.style
    }
  ), T && /* @__PURE__ */ t.createElement(M, { ...T }));
});
N.propTypes = I;
N.displayName = "KendoReactSankey";
export {
  N as Sankey
};
