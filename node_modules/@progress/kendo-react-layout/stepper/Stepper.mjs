/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as a from "react";
import r from "prop-types";
import { StepperContext as ee } from "./context/StepperContext.mjs";
import { validatePackage as te, focusFirstFocusableChild as se, useRtl as ae, dispatchEvent as P, Keys as u, classNames as A, svgIconPropType as F } from "@progress/kendo-react-common";
import { Step as oe } from "./Step.mjs";
import { ProgressBar as re } from "@progress/kendo-react-progressbars";
import { DEFAULT_ANIMATION_DURATION as ne, NO_ANIMATION as le } from "./contants.mjs";
import { packageMetadata as ie } from "../package-metadata.mjs";
import { useLocalization as ce } from "@progress/kendo-react-intl";
import { progBarAriaLabel as M, messages as ue } from "./messages/index.mjs";
const E = a.forwardRef((k, V) => {
  te(ie);
  const {
    animationDuration: b,
    children: L,
    className: D,
    disabled: m,
    errorIcon: z,
    errorSVGIcon: G,
    item: N,
    items: d,
    linear: p,
    mode: K,
    orientation: y,
    style: R,
    successIcon: _,
    successSVGIcon: B,
    onChange: h,
    onFocus: C
  } = k, H = ce().toLanguageString(M, ue[M]), g = a.useRef(null), w = a.useCallback(
    () => {
      g.current && se(g.current);
    },
    []
  ), I = a.useCallback(
    () => ({
      element: g.current,
      focus: w
    }),
    [w]
  );
  a.useImperativeHandle(V, I);
  const l = k.value || O.value, [f, n] = a.useState(l), c = d ? d.length : 0, o = y === "vertical", S = ae(g, k.dir), U = typeof b == "number" ? b : b !== !1 ? ne : le;
  a.useEffect(() => {
    n(l);
  }, [l]);
  const v = a.useCallback(
    (t, s) => {
      const e = s === l - 1, i = s === l, $ = s === l + 1;
      l !== s && h && !m && (!p || e || i || $) && (P(
        h,
        t,
        I(),
        { value: s }
      ), n(s));
    },
    [l, p, h, m, n]
  ), j = a.useCallback(
    (t) => {
      let s = t.value, e = t.syntheticEvent;
      v(e, s);
    },
    [v]
  ), q = a.useCallback(
    (t) => {
      C && !m && P(
        C,
        t.syntheticEvent,
        I(),
        void 0
      );
    },
    [C, m]
  ), x = a.useCallback(
    (t) => {
      v(t, f);
    },
    [v, f]
  ), J = a.useCallback(
    (t) => {
      const s = S === "rtl", e = f, i = d.length - 1;
      switch (t.keyCode) {
        case u.left:
          t.preventDefault(), !s && e > 0 && n(e - 1), s && e < i && n(e + 1);
          break;
        case u.right:
          t.preventDefault(), !s && e < i && n(e + 1), s && e > 0 && n(e - 1);
          break;
        case u.up:
          t.preventDefault(), !s && e > 0 && n(e - 1), s && e > 0 && n(e - 1);
          break;
        case u.down:
          t.preventDefault(), !s && e < i && n(e + 1), s && e < i && n(e + 1);
          break;
        case u.home:
          t.preventDefault(), n(0);
          break;
        case u.end:
          t.preventDefault(), n(i);
          break;
        case u.space:
          t.preventDefault();
          break;
        case u.enter:
          t.preventDefault(), d[e].disabled || x(t);
          break;
      }
    },
    [d, n, f, S, x]
  ), Q = a.useMemo(
    () => A(
      "k-stepper",
      {
        "k-stepper-linear": p
      },
      D
    ),
    [p, D]
  ), W = a.useMemo(
    () => ({
      display: "grid",
      gridTemplateColumns: o ? void 0 : "repeat(" + c * 2 + ", 1fr)",
      gridTemplateRows: o ? "repeat(" + c + ", 1fr)" : void 0,
      ...R
    }),
    [o, c, R]
  ), X = a.useMemo(
    () => A(
      "k-step-list",
      {
        "k-step-list-horizontal": !o,
        "k-step-list-vertical": o
      }
    ),
    [o]
  ), Y = a.useMemo(
    () => ({
      gridColumnStart: o ? void 0 : 1,
      gridColumnEnd: o ? void 0 : -1,
      gridRowStart: o ? 1 : void 0,
      gridRowEnd: o ? -1 : void 0
    }),
    [o]
  ), Z = a.useMemo(
    () => ({
      gridColumnStart: o ? void 0 : 2,
      gridColumnEnd: o ? void 0 : c * 2,
      gridRowStart: o ? 1 : void 0,
      gridRowEnd: o ? c : void 0,
      top: o ? 17 : void 0
    }),
    [o, c]
  ), T = d && d.map((t, s) => {
    const e = {
      index: s,
      disabled: m || t.disabled,
      focused: s === f,
      current: s === l,
      ...t
    }, i = N || oe;
    return /* @__PURE__ */ a.createElement(i, { key: s, ...e });
  });
  return /* @__PURE__ */ a.createElement(
    ee.Provider,
    {
      value: {
        animationDuration: b,
        isVertical: o,
        item: N,
        linear: p,
        mode: K,
        numOfSteps: c,
        value: l,
        successIcon: _,
        successSVGIcon: B,
        errorIcon: z,
        errorSVGIcon: G,
        onChange: j,
        onFocus: q
      }
    },
    /* @__PURE__ */ a.createElement(
      "nav",
      {
        className: Q,
        style: W,
        dir: S,
        onKeyDown: J
      },
      /* @__PURE__ */ a.createElement(
        "ol",
        {
          className: X,
          style: Y
        },
        T || L
      ),
      /* @__PURE__ */ a.createElement(
        re,
        {
          style: Z,
          labelPlacement: "start",
          animation: { duration: U },
          ariaLabel: H,
          "aria-hidden": !0,
          max: c - 1,
          labelVisible: !1,
          orientation: y,
          reverse: y === "vertical",
          value: l,
          disabled: m,
          tabIndex: -1
        }
      )
    )
  );
});
E.propTypes = {
  animationDuration: r.oneOfType([r.bool, r.number]),
  children: r.any,
  className: r.string,
  dir: r.string,
  disabled: r.bool,
  errorIcon: r.string,
  errorSVGIcon: F,
  item: r.any,
  items: r.any,
  linear: r.bool,
  mode: r.oneOf(["steps", "labels"]),
  orientation: r.oneOf(["horizontal", "vertical"]),
  style: r.object,
  successIcon: r.string,
  successSVGIcon: F,
  value: r.number.isRequired,
  onChange: r.func,
  onFocus: r.func
};
const O = {
  value: 0
};
E.defaultProps = O;
E.displayName = "KendoStepper";
export {
  E as Stepper
};
